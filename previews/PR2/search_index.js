var documenterSearchIndex = {"docs":
[{"location":"logroller/#LogRoller.jl","page":"LogRoller.jl","title":"LogRoller.jl","text":"","category":"section"},{"location":"logroller/","page":"LogRoller.jl","title":"LogRoller.jl","text":"Modules = [LogRoller]","category":"page"},{"location":"logroller/#LogRoller.IndexedLogEntry","page":"LogRoller.jl","title":"LogRoller.IndexedLogEntry","text":"IndexedLogEntry represents a log entry as a dictionary and its indexable attributes in a form that is useful to a logging sink.\n\nThe index part contains metadata that are to be indexed. Event metadata consists of attributes like level, module, filepath, line, job id, process id, user id, etc. It also includes application specific keywords that the originating piece of code wishes to index.\n\nKeywords that should be considered as metadata are indicated via the indexable constructor parameter.\n\nWhat metadata can be indexed depends on the type of sink and whether it has support to index certain types of attributes. Attributes that the sink can not index are made part of the message itself for storage.\n\nThe message part can contain the following keys unless they are empty:\n\nmetadata: event metadata that could not be indexed\nmessage: the log message string\nkeywords: any keywords provided\n\nConstructor parameters:\n\nlog: Named tuple containing args to the handle_message method, e.g.: (level, message, _module, group, id, file, line, kwargs)\nindexable: list of names from log and log.kwargs that should be included in the index\n\n\n\n\n\n","category":"type"},{"location":"logroller/#LogRoller.LogEntrySerialization","page":"LogRoller.jl","title":"LogRoller.LogEntrySerialization","text":"Custom JSON serializer for log entries. Handles Module types for now, more can be added later.\n\n\n\n\n\n","category":"type"},{"location":"logroller/#LogRoller.RollingFileWriter","page":"LogRoller.jl","title":"LogRoller.RollingFileWriter","text":"A file writer that implements the IO interface, but only provides write methods.\n\nConstructor parameters:\n\nfilename: name (including path) of file to log into\nsizelimit: size of file (in bytes) after which the file should be rotated\nnfiles: number of rotated files to maintain\n\n\n\n\n\n","category":"type"},{"location":"logroller/#LogRoller.RollingLogger","page":"LogRoller.jl","title":"LogRoller.RollingLogger","text":"RollingLogger(filename, sizelimit, nfiles, minlevel=Info; timestampidentifier::Symbol=:time, format::Symbol=:console) Log into a log file. Rotate log file based on file size. Compress rotated logs.\n\nLogs can be formatted as JSON by setting the optional keyword argument format to :json. A JSON formatted log entry is a JSON object. It should have these keys (unless they are empty): The message part can contain the following keys unless they are empty:\n\nmetadata: event metadata e.g. timestamp, line, filename, ...\nmessage: the log message string\nkeywords: any keywords provided\n\n\n\n\n\n","category":"type"},{"location":"logroller/#Base.close-Tuple{LogRoller.RollingFileWriter}","page":"LogRoller.jl","title":"Base.close","text":"Close any open file handle and streams. A closed object must not be used again.\n\n\n\n\n\n","category":"method"},{"location":"logroller/#Base.close-Tuple{LogRoller.RollingLogger}","page":"LogRoller.jl","title":"Base.close","text":"Close any open file handle and streams. A closed object must not be used again.\n\n\n\n\n\n","category":"method"},{"location":"logroller/#Base.write-Tuple{LogRoller.RollingFileWriter, UInt8}","page":"LogRoller.jl","title":"Base.write","text":"Write into the underlying stream, rolling over as and when necessary.\n\n\n\n\n\n","category":"method"},{"location":"logroller/#LogRoller.RollingFileWriterTee","page":"LogRoller.jl","title":"LogRoller.RollingFileWriterTee","text":"Tees raw log entries made a RollingFileWriter on to a provided Julia AbstractLogger.\n\nEach line of text is taken as a single log message.\n\nAll log entries are made with the same log level, which can be provided during construction. It leaves further examination/parsing of log messages (to extract parameters, or detect exact log levels) to the downstream logger.\n\n\n\n\n\n","category":"function"},{"location":"logroller/#LogRoller.postrotate-Tuple{Function, LogRoller.RollingFileWriter}","page":"LogRoller.jl","title":"LogRoller.postrotate","text":"Register a function to be called with the rotated file name just after the current log file is rotated. The file name of the rotated file is passed as an argument. The function is blocking and so any lengthy operation that needs to be done should be done asynchronously.\n\n\n\n\n\n","category":"method"},{"location":"logroller/#LogRoller.postrotate-Tuple{Function, LogRoller.RollingLogger}","page":"LogRoller.jl","title":"LogRoller.postrotate","text":"Register a function to be called with the rotated file name just after the current log file is rotated. The file name of the rotated file is passed as an argument. The function is blocking and so any lengthy operation that needs to be done should be done asynchronously.\n\n\n\n\n\n","category":"method"},{"location":"logroller/#LogRoller.rotate_file-Tuple{LogRoller.RollingFileWriter}","page":"LogRoller.jl","title":"LogRoller.rotate_file","text":"Rotate files as below with increasing age:     - <filename> : active file     - <filename>1.gz : last rotated file     - <filename>2.gz : previous <filename>1.gz rotated to <filename>2.gz     - <filename>3.gz : previous <filename>2.gz rotated to <filename>3.gz     - ...     - <filename>n.gz : last rotated file is discarded when rotated\n\n\n\n\n\n","category":"method"},{"location":"logroller/#LogRoller.tee-Tuple{LogRoller.RollingFileWriter, Base.CoreLogging.AbstractLogger, Base.CoreLogging.LogLevel}","page":"LogRoller.jl","title":"LogRoller.tee","text":"Tee all lines to the provided logger\n\n\n\n\n\n","category":"method"},{"location":"logging2/#Logging2.jl","page":"Logging2.jl","title":"Logging2.jl","text":"","category":"section"},{"location":"logging2/","page":"Logging2.jl","title":"Logging2.jl","text":"Modules = [Logging2]","category":"page"},{"location":"logging2/#Logging2.LineBufferedIO","page":"Logging2.jl","title":"Logging2.LineBufferedIO","text":"LineBufferedIO(dest::IO)\n\nA thread safe line buffered IO wrapper which buffers writes until a full line (delimited by '\\n') is received. Full lines are written to the downstream dest IO.\n\nTo ensure that the tail of the stream is written (even without a trailing '\\n'), be sure to call close().\n\n\n\n\n\n","category":"type"},{"location":"logging2/#Logging2.LoggingStream","page":"Logging2.jl","title":"Logging2.LoggingStream","text":"LoggingStream(logger; level, id)\n\nAn IO object which collects incoming calls to write and writes them to the Julia logging system via logger. Most useful when combined with LineBufferedIO. The standard logging _id field will be set to id.\n\n\n\n\n\n","category":"type"},{"location":"logging2/#Base.redirect_stderr","page":"Logging2.jl","title":"Base.redirect_stderr","text":"redirect_stderr(f::Function, logger::AbstractLogger)\n\nRedirect the global stderr stream to logger, with each line becoming a log event during the execution of the function f.\n\nSee redirect_stdout for examples and additional information.\n\n\n\n\n\n","category":"function"},{"location":"logging2/#Base.redirect_stdout","page":"Logging2.jl","title":"Base.redirect_stdout","text":"redirect_stdout(f::Function, logger::AbstractLogger)\n\nRedirect the global stdout stream to logger, with each line becoming a log event during the execution of the function f.\n\nnote: Note\nIn contrast to the dynamic scope of the usual logging system frontend (@info, etc), stdout is a global object so it's not entirely clear that we can collect the logger from the current dynamic scope where Base.stdout is looked up, and efficiently use it.In particular, some particular uses of stdout require it to have an operating system primitive like a Pipe backing the object. However not all uses require this, and it may be possible to improve the situation in the future.\n\nExamples\n\nHere's how you use redirect_stdout in structured concurrency style:\n\nredirect_stdout(current_logger()) do\n    println(\"Hi\")\n    run(`ls`)\nend\n\n\n\n\n\n","category":"function"},{"location":"terminalloggers/#TerminalLoggers.jl","page":"TerminalLoggers.jl","title":"TerminalLoggers.jl","text":"","category":"section"},{"location":"terminalloggers/","page":"TerminalLoggers.jl","title":"TerminalLoggers.jl","text":"Modules = [TerminalLoggers]","category":"page"},{"location":"terminalloggers/#TerminalLoggers.TerminalLoggers","page":"TerminalLoggers.jl","title":"TerminalLoggers.TerminalLoggers","text":"TerminalLoggers\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Codecov)\n\nTerminalLoggers provides a logger type TerminalLogger which can format your log messages in a richer way than the default ConsoleLogger which comes with the julia standard Logging library.\n\nRead the documentation for more information.\n\n\n\n\n\n","category":"module"},{"location":"terminalloggers/#TerminalLoggers.StickyMessages","page":"TerminalLoggers.jl","title":"TerminalLoggers.StickyMessages","text":"StickyMessages(io::IO; ansi_codes=io isa Base.TTY && \n               (!Sys.iswindows() || VERSION >= v\"1.5.3\"))\n\nA StickyMessages type manages the display of a set of persistent \"sticky\" messages in a terminal. That is, messages which are not part of the normal scrolling output. Each message is identified by a label and may may be added to the set using push!(messages, label=>msg), and removed using pop!(messages, label), or empty!().\n\nOnly a single StickyMessages object should be associated with a given TTY, as the object manipulates the terminal scrolling region.\n\n\n\n\n\n","category":"type"},{"location":"terminalloggers/#TerminalLoggers.TerminalLogger","page":"TerminalLoggers.jl","title":"TerminalLoggers.TerminalLogger","text":"TerminalLogger(stream=stderr, min_level=LogLevel(-1); meta_formatter=default_metafmt,\n               show_limited=true, right_justify=0)\n\nLogger with formatting optimized for interactive readability in a text console (for example, the Julia REPL). This is an enhanced version of the terminal logger Logging.ConsoleLogger which comes installed with Julia by default.\n\nLog levels less than min_level are filtered out.\n\nMessage formatting can be controlled by setting keyword arguments:\n\nmeta_formatter is a function which takes the log event metadata (level, _module, group, id, file, line) and returns a color (as would be passed to printstyled), prefix and suffix for the log message.  The default is to prefix with the log level and a suffix containing the module, file and line location.\nshow_limited limits the printing of large data structures to something which can fit on the screen by setting the :limit IOContext key during formatting.\nright_justify is the integer column which log metadata is right justified at. The default is zero (metadata goes on its own line).\n\n\n\n\n\n","category":"type"},{"location":"loggingextras/#LoggingExtras.jl","page":"LoggingExtras.jl","title":"LoggingExtras.jl","text":"","category":"section"},{"location":"loggingextras/","page":"LoggingExtras.jl","title":"LoggingExtras.jl","text":"Modules = [LoggingExtras]","category":"page"},{"location":"loggingextras/#LoggingExtras.ActiveFilteredLogger","page":"LoggingExtras.jl","title":"LoggingExtras.ActiveFilteredLogger","text":"ActiveFilteredLogger(filter, logger)\n\nWraps logger in an active filter. While loggers intrinsictally have in built filtering mechanisms. Wrapping it in a ActiveFilterLogger allows for extract control, at the cost of a bit of overhead.\n\nThe ActiveFilteredLogger has full control of what is logged, as it sees the full message, this does mean however it determines what to log at runtime, which is the source of the overhead. The EarlyFilteredLogger has less control, but decides if to log before the message is computed.\n\nThe filter should be a function that returns a boolean. true if the message should be logged and false if not. As input it will be given a named tuple with the following fields: (level, message, _module, group, id, file, line, kwargs) See ?LoggingExtra.handle_message_args for more information on what each is.\n\n\n\n\n\n","category":"type"},{"location":"loggingextras/#LoggingExtras.EarlyFilteredLogger","page":"LoggingExtras.jl","title":"LoggingExtras.EarlyFilteredLogger","text":"EarlyFilteredLogger(filter, logger)\n\nWraps logger in an filter that runs before the log message is created.\n\nFor contrast see the ActiveFilteredLogger which has full control, but runs after the log message content is computed. In most circumstances this is fine, but if your log messages are expensive to create (e.g. they include summary statistics), then the EarlyFilteredLogger is going to be better.\n\nThe filter should be a function that returns a boolean. true if the message should be logged and false if not. As input it will be given a named tuple with the following fields: (level, _module, group, id) See ?LoggingExtra.shouldlog_args for more information on what each is.\n\n\n\n\n\n","category":"type"},{"location":"loggingextras/#LoggingExtras.FileLogger-Tuple{Any}","page":"LoggingExtras.jl","title":"LoggingExtras.FileLogger","text":"FileLogger(path::AbstractString; append=false, always_flush=true)\n\nCreate a logger sink that write messages to a file specified with path. To append to the file (rather than truncating the file first), use append=true. If always_flush=true the stream is flushed after every handled log message.\n\n\n\n\n\n","category":"method"},{"location":"loggingextras/#LoggingExtras.FileLogger-Tuple{IOStream}","page":"LoggingExtras.jl","title":"LoggingExtras.FileLogger","text":"FileLogger(io::IOStream; always_flush=true)\n\nCreate a logger sink that write messages to the io::IOStream. The stream is expected to be open and writeable. If always_flush=true the stream is flushed after every handled log message.\n\nExamples\n\nio = open(\"path/to/file.log\", \"a\") # append to the file\nlogger = FileLogger(io)\n\n\n\n\n\n","category":"method"},{"location":"loggingextras/#LoggingExtras.FormatLogger","page":"LoggingExtras.jl","title":"LoggingExtras.FormatLogger","text":"FormatLogger(f::Function, io::IO=stderr; always_flush=true)\n\nLogger sink that formats the message and finally writes to io. The formatting function should be of the form f(io::IOContext, log_args::NamedTuple) where log_args has the following fields: (level, message, _module, group, id, file, line, kwargs). See ?LoggingExtra.handle_message_args for more information on what field is.\n\nExamples\n\njulia> using Logging, LoggingExtras\n\njulia> logger = FormatLogger() do io, args\n           println(io, args._module, \" | \", \"[\", args.level, \"] \", args.message)\n       end;\n\njulia> with_logger(logger) do\n           @info \"This is an informational message.\"\n           @warn \"This is a warning, should take a look.\"\n       end\nMain | [Info] This is an informational message.\nMain | [Warn] This is a warning, should take a look.\n\n\n\n\n\n","category":"type"},{"location":"loggingextras/#LoggingExtras.MinLevelLogger","page":"LoggingExtras.jl","title":"LoggingExtras.MinLevelLogger","text":"MinLevelLogger(logger, min_enabled_level)\n\nWraps logger in an filter that runs before the log message is created. In many ways this is just a specialised EarlyFilteredLogger that only checks the level. This filter only allowed messages on or above the min_enabled_level to pass.\n\n\n\n\n\n","category":"type"},{"location":"loggingextras/#LoggingExtras.TeeLogger-Tuple{Vararg{Base.CoreLogging.AbstractLogger, N} where N}","page":"LoggingExtras.jl","title":"LoggingExtras.TeeLogger","text":"TeeLogger(loggers...)\n\nSend the same log message to all the loggers.\n\nTo include the current logger do: TeeLogger(current_logger(), loggers...) to include the global logger, do: TeeLogger(global_logger(), loggers...)\n\n\n\n\n\n","category":"method"},{"location":"loggingextras/#LoggingExtras.TransformerLogger","page":"LoggingExtras.jl","title":"LoggingExtras.TransformerLogger","text":"TransformerLogger(f, logger)\n\nPreprocesses log messages, using the function f, before passing them to the logger that is wrapped. This can be used, for example, to truncate a log message. to conditionally change the log level of logs from a given module (which depending on the wrappped logger, might cause the message to be dropped).\n\nThe transforming function f is given a named tuple with the fields: (level, message, _module, group, id, file, line, kwargs) and should return the same. See ?LoggingExtra.handle_message_args for more information on what each is.\n\n\n\n\n\n","category":"type"},{"location":"loggingextras/#LoggingExtras.handle_message_args-Tuple","page":"LoggingExtras.jl","title":"LoggingExtras.handle_message_args","text":"handle_message_args\n\nThis creates NamedTuple containing all the arguments the logger gives to handle_message It is the type pased to the active logger filter. These argument come from the logging macro (@info,@warn` etc).\n\nlevel::LogLevel Warn, Info, etc,\nmessage::String the message to be logged\n_module::Module can be used to specify a different originating module from the source location of the message.\ngroup::Symbol can be used to override the message group (this is normally derived from the base name of the source file).\nid::Symbol can be used to override the automatically generated unique message identifier.  This is useful if you need to very closely associate messages generated on different source lines.\nfile::String and line::Int can be used to override the apparent source location of a log message.\nkwargs...: Any  keyword or position arguments passed to the logging macro\n\n\n\n\n\n","category":"method"},{"location":"loggingextras/#LoggingExtras.next_datetime_transition-Tuple{Dates.DateFormat}","page":"LoggingExtras.jl","title":"LoggingExtras.next_datetime_transition","text":"next_datetime_transition(fmt::DateFormat)\n\nGiven a DateFormat that is being applied to our filename, what is the next time at which our filepath will need to change?\n\n\n\n\n\n","category":"method"},{"location":"loggingextras/#LoggingExtras.shouldlog_args-Tuple","page":"LoggingExtras.jl","title":"LoggingExtras.shouldlog_args","text":"shouldlog_args\n\nThis returns a NamedTuple containing all the arguments the logger gives to shouldlog It is passed to the early logger filter. These argument come from the logging macro (@info,@warn` etc).\n\nlevel::LogLevel Warn, Info, etc,\n_module::Module can be used to specify a different originating module from the source location of the message.\ngroup::Symbol can be used to override the message group (this is normally derived from the base name of the source file).\nid::Symbol can be used to override the automatically generated unique message identifier.  This is useful if you need to very closely associate messages generated on different source lines.\n\n\n\n\n\n","category":"method"},{"location":"logging/#Logging.jl","page":"Logging.jl","title":"Logging.jl","text":"","category":"section"},{"location":"logging/","page":"Logging.jl","title":"Logging.jl","text":"Logging.@logmsg\nLogging.SimpleLogger\nLogging.ConsoleLogger","category":"page"},{"location":"logging/#Logging.@logmsg","page":"Logging.jl","title":"Logging.@logmsg","text":"@debug message  [key=value | value ...]\n@info  message  [key=value | value ...]\n@warn  message  [key=value | value ...]\n@error message  [key=value | value ...]\n\n@logmsg level message [key=value | value ...]\n\nCreate a log record with an informational message.  For convenience, four logging macros @debug, @info, @warn and @error are defined which log at the standard severity levels Debug, Info, Warn and Error.  @logmsg allows level to be set programmatically to any LogLevel or custom log level types.\n\nmessage should be an expression which evaluates to a string which is a human readable description of the log event.  By convention, this string will be formatted as markdown when presented.\n\nThe optional list of key=value pairs supports arbitrary user defined metadata which will be passed through to the logging backend as part of the log record.  If only a value expression is supplied, a key representing the expression will be generated using Symbol. For example, x becomes x=x, and foo(10) becomes Symbol(\"foo(10)\")=foo(10).  For splatting a list of key value pairs, use the normal splatting syntax, @info \"blah\" kws....\n\nThere are some keys which allow automatically generated log data to be overridden:\n\n_module=mod can be used to specify a different originating module from the source location of the message.\n_group=symbol can be used to override the message group (this is normally derived from the base name of the source file).\n_id=symbol can be used to override the automatically generated unique message identifier.  This is useful if you need to very closely associate messages generated on different source lines.\n_file=string and _line=integer can be used to override the apparent source location of a log message.\n\nThere's also some key value pairs which have conventional meaning:\n\nmaxlog=integer should be used as a hint to the backend that the message should be displayed no more than maxlog times.\nexception=ex should be used to transport an exception with a log message, often used with @error. An associated backtrace bt may be attached using the tuple exception=(ex,bt).\n\nExamples\n\n@debug \"Verbose debugging information.  Invisible by default\"\n@info  \"An informational message\"\n@warn  \"Something was odd.  You should pay attention\"\n@error \"A non fatal error occurred\"\n\nx = 10\n@info \"Some variables attached to the message\" x a=42.0\n\n@debug begin\n    sA = sum(A)\n    \"sum(A) = $sA is an expensive operation, evaluated only when `shouldlog` returns true\"\nend\n\nfor i=1:10000\n    @info \"With the default backend, you will only see (i = $i) ten times\"  maxlog=10\n    @debug \"Algorithm1\" i progress=i/10000\nend\n\n\n\n\n\n","category":"macro"},{"location":"logging/#Logging.SimpleLogger","page":"Logging.jl","title":"Logging.SimpleLogger","text":"SimpleLogger(stream=stderr, min_level=Info)\n\nSimplistic logger for logging all messages with level greater than or equal to min_level to stream.\n\n\n\n\n\n","category":"type"},{"location":"logging/#Logging.ConsoleLogger","page":"Logging.jl","title":"Logging.ConsoleLogger","text":"ConsoleLogger(stream=stderr, min_level=Info; meta_formatter=default_metafmt,\n              show_limited=true, right_justify=0)\n\nLogger with formatting optimized for readability in a text console, for example interactive work with the Julia REPL.\n\nLog levels less than min_level are filtered out.\n\nMessage formatting can be controlled by setting keyword arguments:\n\nmeta_formatter is a function which takes the log event metadata (level, _module, group, id, file, line) and returns a color (as would be passed to printstyled), prefix and suffix for the log message.  The default is to prefix with the log level and a suffix containing the module, file and line location.\nshow_limited limits the printing of large data structures to something which can fit on the screen by setting the :limit IOContext key during formatting.\nright_justify is the integer column which log metadata is right justified at. The default is zero (metadata goes on its own line).\n\n\n\n\n\n","category":"type"},{"location":"progresslogging/#ProgressLogging.jl","page":"ProgressLogging.jl","title":"ProgressLogging.jl","text":"","category":"section"},{"location":"progresslogging/","page":"ProgressLogging.jl","title":"ProgressLogging.jl","text":"Modules = [ProgressLogging]","category":"page"},{"location":"progresslogging/#ProgressLogging.ProgressLogging","page":"ProgressLogging.jl","title":"ProgressLogging.ProgressLogging","text":"ProgressLogging: a package for defining progress logs\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Codecov) (Image: Coveralls)\n\nProgressLogging.jl is a package for defining progress logs.  It can be used to report progress of a loop/loops with time-consuming body:\n\njulia> using ProgressLogging\n\njulia> @progress for i in 1:10\n           sleep(0.1)\n       end\n\nThis package does not contain any progress monitors for visualizing the progress of the program.  You need to install a package supporting progress logs created by ProgressLogging.jl API.  For example:\n\nJuno\nTerminalLoggers.jl\n\n\n\n\n\n","category":"module"},{"location":"progresslogging/#ProgressLogging.ROOTID","page":"ProgressLogging.jl","title":"ProgressLogging.ROOTID","text":"ProgressLogging.ROOTID\n\nThis is used as parentid of root Progresses.\n\n\n\n\n\n","category":"constant"},{"location":"progresslogging/#ProgressLogging.Progress","page":"ProgressLogging.jl","title":"ProgressLogging.Progress","text":"ProgressLogging.Progress(id, [fraction]; [parentid, name, done])\n\nUsage: Progress log record provider\n\nProgress log record can be created by using the following pattern\n\nid = uuid4()\ntry\n    @info Progress(id)  # create a progress bar\n    # some time consuming job\n    # ...\n    @info Progress(id, 0.1)  # update progress to 10%\n    # ...\nfinally\n    @info Progress(id, done = true)  # close the progress bar\nend\n\nIt is recommended to use @withprogress, @logprogress, and optionally @progressid to create log records.\n\nUsage: Progress log record consumer (aka progress monitor)\n\nIt is recommended to use ProgressLogging.asprogress instead of checking message isa Progress.  Progress monitors can retrieve progress-related information from the following properties.\n\nProperties\n\nfraction::Union{Float64,Nothing}: it can take following values:\n0 <= fraction < 1\nfraction >= 1: completed\nfraction = nothing: indeterminate progress\nid::UUID: Identifier of the job whose progress is at fraction.\nparentid::UUID: The ID of the parent progress.  It is set to ProgressLogging.ROOTID when there is no parent progress. This is used for representing progresses of nested jobs.  Note that sub-jobs may be executed concurrently; i.e., there can be multiple child jobs for one parent job.\nname::String: Name of the progress bar.\ndone::Bool: true if the job is done.\n\n\n\n\n\n","category":"type"},{"location":"progresslogging/#ProgressLogging.asprogress-Tuple{Any, ProgressLogging.Progress, Vararg{Any, N} where N}","page":"ProgressLogging.jl","title":"ProgressLogging.asprogress","text":"ProgressLogging.asprogress(_, name, _, _, id, _, _; progress, ...) :: Union{Progress, Nothing}\n\nPre-process log record to obtain a Progress object if it is one of the supported format.  This is mean to be used with the message positional argument and all keyword arguments passed to Logging.handle_message.  Example:\n\nfunction Logging.handle_message(logger::MyLogger, args...; kwargs...)\n    progress = ProgressLogging.asprogress(args...; kwargs...)\n    if progress !== nothing\n        return # handle progress log record\n    end\n    # handle normal log record\nend\n\n\n\n\n\n","category":"method"},{"location":"progresslogging/#ProgressLogging.progress-Tuple{Any}","page":"ProgressLogging.jl","title":"ProgressLogging.progress","text":"progress(f::Function; name = \"\")\n\nEvaluates f with id as its argument and makes sure to destroy the progress bar afterwards. To update the progress bar in f you can call a logging statement like @info or even just @logmsg with _id=id and progress as arguments.\n\nprogress can take either of the following values:\n\n0 <= progress < 1: create or update progress bar\nprogress == nothing || progress = NaN: set progress bar to indeterminate progress\nprogress >= 1 || progress == \"done\": destroy progress bar\n\nThe logging message (e.g. \"foo\" in @info \"foo\") will be used as the progress bar's name.\n\nLog level must be higher or equal to LogLevel(-1).\n\nProgressLogging.progress() do id\n    for i = 1:10\n        sleep(0.5)\n        @info \"iterating\" progress=i/10 _id=id\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"progresslogging/#ProgressLogging.@logprogress","page":"ProgressLogging.jl","title":"ProgressLogging.@logprogress","text":"@logprogress [name] progress [key1=val1 [key2=val2 ...]]\n\nThis macro must be used inside @withprogress macro.\n\nLog a progress event with a value progress.  The expression progress must be evaluated to be a real number between 0 and 1 (inclusive), a NaN, or a string \"done\".\n\nOptional first argument name can be used to change the name of the progress bar.  Additional keyword arguments are passed to @logmsg.\n\n\n\n\n\n","category":"macro"},{"location":"progresslogging/#ProgressLogging.@progress-Tuple","page":"ProgressLogging.jl","title":"ProgressLogging.@progress","text":"@progress [name=\"\", threshold=0.005] for i = ..., j = ..., ...\n@progress [name=\"\", threshold=0.005] x = [... for i = ..., j = ..., ...]\n\nShow a progress meter named name for the given loop or array comprehension if possible. Update frequency is limited by threshold (one update per 0.5% of progress by default).\n\n\n\n\n\n","category":"macro"},{"location":"progresslogging/#ProgressLogging.@progressid-Tuple{}","page":"ProgressLogging.jl","title":"ProgressLogging.@progressid","text":"@progressid\n\nGet the progress ID of current lexical scope.\n\n\n\n\n\n","category":"macro"},{"location":"progresslogging/#ProgressLogging.@withprogress-Tuple","page":"ProgressLogging.jl","title":"ProgressLogging.@withprogress","text":"@withprogress [name=\"\"] [parentid=uuid4()] ex\n\nCreate a lexical environment in which @logprogress can be used to emit progress log events without manually specifying the log level, _id, and name (log message).\n\n@withprogress name=\"iterating\" begin\n    for i = 1:10\n        sleep(0.5)\n        @logprogress i/10\n    end\nend\n\n\n\n\n\n","category":"macro"},{"location":"sysloglogging/#SyslogLogging.jl","page":"SyslogLogging.jl","title":"SyslogLogging.jl","text":"","category":"section"},{"location":"sysloglogging/","page":"SyslogLogging.jl","title":"SyslogLogging.jl","text":"Modules = [SyslogLogging]","category":"page"},{"location":"sysloglogging/#SyslogLogging.SyslogLogger","page":"SyslogLogging.jl","title":"SyslogLogging.SyslogLogger","text":"Logs messages to a syslog facility.\n\n\n\n\n\n","category":"type"},{"location":"lokilogger/#LokiLogger.jl","page":"LokiLogger.jl","title":"LokiLogger.jl","text":"","category":"section"},{"location":"lokilogger/","page":"LokiLogger.jl","title":"LokiLogger.jl","text":"Modules = [LokiLogger]","category":"page"},{"location":"lokilogger/#LokiLogger.Logger","page":"LokiLogger.jl","title":"LokiLogger.Logger","text":"LokiLogger.Logger(server::Union{String,URI}; labels::Dict)\nLokiLogger.Logger(fmt::Function, server::Union{String,URI}; labels::Dict)\n\nCreate a logger that send messages to a Loki server.\n\nThe log messages are attributed with the labels given in the labels dictionary. If no labels are specified the default labels are:\n\n\"host\" => gethostname()\n\"app\"  => \"LokiLogger.jl\"\n\nThe fmt argument is used for formatting. There are two builtin formatting functions:\n\nLokiLogger.logfmt (default): formats the log message in the logfmt format,\nLokiLogger.json: formats the log message as JSON.\n\nCustom functions must take two arguments: an io::IO to write the message to, and args::NamedTuple that contains all the logger arguments, see help for LoggingExtras.handle_message_args for details.\n\nExamples\n\n# Create a logger with a single label and default (logfmt) formatting\nlogger = LokiLogger.Logger(\"http://localhost:3100\"; labels = Dict(\"app\" => \"myapp\"))\n\n# Create a logger with json output formatting\nlogger = LokiLogger.Logger(LokiLogger.json, \"http://localhost:3100\")\n\n# Create a logger with custom formatting\nlogger = LokiLogger.Logger(\"http://localhost:3100\") do io, args\n    # Only output the level and the message\n    print(io, args.level, \": \", args.message)\nend\n\n\n\n\n\n","category":"type"},{"location":"lokilogger/#LokiLogger.json-Tuple{IO, Any}","page":"LokiLogger.jl","title":"LokiLogger.json","text":"json(io::IO, args)\n\nFormat the log message as JSON and write to io.\n\nExample logline:\n\n{\"level\":\"info\",\"msg\":\"hello, world\",\"module\":\"Main\",\"file\":\"/run.jl\",\"line\":2,\"group\":\"run\",\"id\":\"Main_6972c827\"}\n\n\n\n\n\n","category":"method"},{"location":"lokilogger/#LokiLogger.logfmt-Tuple{IO, Any}","page":"LokiLogger.jl","title":"LokiLogger.logfmt","text":"logfmt(io::IO, args)\n\nFormat the log message in logfmt key-value format and print to io.\n\nExample logline:\n\nlevel=info msg=\"hello, world\" module=Main file=\"/run.jl\" line=2 group=run id=Main_6972c827\n\n\n\n\n\n","category":"method"},{"location":"how-to/enable-debug/#How-to-enable-@debug-messages","page":"How to enable @debug messages","title":"How to enable @debug messages","text":"","category":"section"},{"location":"how-to/enable-debug/","page":"How to enable @debug messages","title":"How to enable @debug messages","text":"To be written...","category":"page"},{"location":"logcompose/#LogCompose.jl","page":"LogCompose.jl","title":"LogCompose.jl","text":"","category":"section"},{"location":"logcompose/","page":"LogCompose.jl","title":"LogCompose.jl","text":"Modules = [LogCompose]","category":"page"},{"location":"#JuliaLogging","page":"Home","title":"JuliaLogging","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the landing page of the JuliaLogging GitHub organization. JuliaLogging is an umbrella organization for logging-related packages and repositories in the Julia programming language ecosystem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here's a summary of libraries which integrate with the standard logging frontend macros @debug, @info, @warn, @error from Base and with the abstractions from the Logging standard library.","category":"page"},{"location":"#Frontend","page":"Home","title":"Frontend","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ProgressLogging.jl provides some convenient frontend macros including @progress which makes it easy to emit log records tracking the progress of looping constructs.","category":"page"},{"location":"#Log-Event-routing-and-transformation","page":"Home","title":"Log Event routing and transformation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LoggingExtras.jl provides generic log transformation, filtering and routing functionality. You can use this to mutate messages as they go through the chain, duplicate a stream of log records into multiple streams, discard messages based on a predicate, etc.\nLogging2.jl provides utilities to redirect","category":"page"},{"location":"#Sinks","page":"Home","title":"Sinks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Logging stdlib provides a default logger backend ConsoleLogger for basic filtering and pretty printing of log records in the terminal.\nTerminalLoggers.jl is a library for advanced terminal-based pretty printing of log records, including fancy progress bars and markdown formatting.\nTensorBoardLogger.jl can log structured numeric data to TensorBoard as a backend.\nLogRoller.jl has a backend for rotating log files once they hit a size limit.\nSyslogging.jl provides a backend to direct logs to syslog.\nLoggingExtras.jl provides a simple FileLogger sink.\nLokiLogger is a log message sink for Grafana Loki","category":"page"},{"location":"#Configuration","page":"Home","title":"Configuration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LogCompose.jl provides declarative logger configuration and an associated .toml file format.","category":"page"},{"location":"how-to/log-to-file/#How-to-log-to-a-file","page":"How to log to a file","title":"How to log to a file","text":"","category":"section"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"To be written...","category":"page"}]
}
